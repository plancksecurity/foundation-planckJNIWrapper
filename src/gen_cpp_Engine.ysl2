include yslt.yml2

tstylesheet {
    include ./types_c.ysl2

    template "/namespace[@name='pEp']" apply "interface", 0;

    template "interface" document("org_pEp_jniadapter_{@name}.cc", "text")
        ||
        #include <assert.h>
        #include "org_pEp_jniadapter_«@name».h"
        #include "jniutils.hh"

        using namespace pEp::JNIAdapter;

        `` apply "method", 0
        ||

    template "method" {
        const "mangled" call "mangle";
        const "jtype" call "CamelCase" with "text", "name(parm[creates|returns]/*[2])";

        ||
        JNIEXPORT jobject JNICALL «$mangled»(
                JNIEnv *env,
                jobject obj`apply "parm[in]", mode=sig`
            )
        {
        ||

        choose {
            when "count(parm[returns|creates]) > 1"
                |> jclass clazz = findClass(env, "org/pEp/jniadapter/_«@name»_Return");
            when "count(parm[returns|creates]) = 1" {
                |> jclass clazz = findClass(env, "org/pEp/jniadapter/«$jtype»");
            }
        }

        ||
            jmethodID constructor = env->GetMethodID(clazz, "<init>", "()V");
            assert(constructor);
            jobject result = env->NewObject(clazz, constructor);

            return result;
        }

        ||
    }

    function "mangle" {
        const "convert", "count(parm/stringlist|parm/string|parm/identity) > 0";

        choose {
            when "$convert"
                > «concat('Java_org_pEp_jniadapter_', ../@name, '__1', str:replace(@name, '_', '_1'))»
            otherwise
                > «concat('Java_org_pEp_jniadapter_', ../@name, '_', str:replace(@name, '_', '_1'))»
        }
    }

    template "parm", mode=sig {
        const "name", "name(*[3])";
        > ,\n        jobject «$name»
    }
}

