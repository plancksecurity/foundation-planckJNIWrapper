include yslt.yml2

tstylesheet {
    include ./textutils.ysl2
    include ./types_c.ysl2
    include ./types_java.ysl2

    template "/namespace[@name='pEp']" apply "interface", 0;

    template "interface" document("org_pEp_jniadapter_{@name}.cc", "text")
        ||
        #include <assert.h>
        #include <pEp/message_api.h>
        #include "org_pEp_jniadapter_«@name».h"
        #include "jniutils.hh"

        using namespace pEp::JNIAdapter;

        extern "C" {

        `` apply "method", 0
        } // extern "C"

        ||

    template "method" {
        const "mangled" call "mangle";
        const "rettype", "name(parm[creates|returns]/*[2])";
        const "retname", "name(parm[creates|returns]/*[3])";
        const "jtype" call "toJavaDeclare" with "type", "$rettype";

        ||
        JNIEXPORT jobject JNICALL «$mangled»(
                JNIEnv *env,
                jobject obj`apply "parm[in]", mode=sig`
            )
        {
            PEP_SESSION session = (PEP_SESSION) callLongMethod(env, obj, "getHandle");

            `` apply "parm[in]", mode=in
            `` apply "parm[creates|returns]", mode=out

            PEP_STATUS status = ::«@name»(session`apply "parm", mode=call``if "@name = 'encrypt_message'" > , PEP_enc_PEP`);

        ||

        choose {
            when "count(parm[returns|creates]) > 1" {
                apply "parm[returns|creates]", mode=return {
                    with "retname", "'result'";
                }

            }

            when "count(parm[returns|creates]) = 1" choose {
                when "$rettype = 'Color'" apply "parm[returns|creates]", mode=return {
                    with "name", "'result'";
                    with "jtype", "$jtype";
                    with "jnitype", "'jint'";
                    with "retname", "$retname";
                    with "sig", "'(I)V'";
                }

                when "$rettype = 'message'" apply "parm[returns|creates]", mode=return {
                    with "name", "'result'";
                    with "jtype", "$jtype";
                    with "jnitype", "'jlong'";
                    with "retname", "$retname";
                    with "sig", "'(J)V'";
                }

                otherwise error | # not implemented: return type "«$rettype»"
            }
        }

        ||
            return result;
        }

        ||
    }

    template "parm", mode=return {
        param "jtype" call "toJavaDeclare" with "type", "name(*[2])";
        param "name", "concat(name(*[3]), '_')";
        param "jnitype";
        param "retname";
        param "sig", "'()V'";

        ||
        jclass clazz_«$name» = findClass(env, "org/pEp/jniadapter/«$jtype»");
        jmethodID constructor_«$name» = env->GetMethodID(clazz_«$name», "<init>", "«$sig»");
        assert(constructor_«$name»);
        ||
        indent(0);
        > jobject «$name» = env->NewObject(clazz_«$name», constructor_«$name»
        if "$jnitype" > , («$jnitype») _«$retname»
        > );\n\n
    }

    template "parm", mode=in {
        const "type", "name(*[2])";
        const "name", "name(*[3])";

        choose {
            when "$type = 'message'"
                | message *_«$name» = (message *) callLongMethod(env, «$name», "getHandle");
            otherwise
                | √$type *_«$name» = to_«$type»(env, «$name»);
        }
    }

    template "parm", mode=out {
        const "type", "name(*[2])";
        const "name", "name(*[3])";

        choose {
            when "$type = 'Color'"
                | PEP_color _«$name»;
            otherwise
                | √$type *_«$name»;
        }
    }

    template "parm", mode=call {
        const "dir", "name(*[1])";
        const "name", "name(*[3])";
     
        > , 
        if "$dir = 'creates' or $dir = 'returns'" > &
        > _«$name»
    }

    function "mangle" {
        const "convert", "count(parm/stringlist|parm/string|parm/identity) > 0";

        choose {
            when "$convert"
                > «concat('Java_org_pEp_jniadapter_', ../@name, '__1', str:replace(@name, '_', '_1'))»
            otherwise
                > «concat('Java_org_pEp_jniadapter_', ../@name, '_', str:replace(@name, '_', '_1'))»
        }
    }

    template "parm", mode=sig {
        const "name", "name(*[3])";
        > ,\n        jobject «$name»
    }
}

