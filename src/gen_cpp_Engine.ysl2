include yslt.yml2

tstylesheet {
    include ./textutils.ysl2
    include ./types_c.ysl2
    include ./types_java.ysl2

    template "/namespace[@name='pEp']" apply "interface", 0;

    template "interface" document("org_pEp_jniadapter_{@name}.cc", "text")
        ||
        #include <assert.h>
        #include <pEp/message_api.h>
        #include <pEp/blacklist.h>
        #include "org_pEp_jniadapter_«@name».h"
        #include "throw_pEp_exception.hh"
        #include "jniutils.hh"

        using namespace pEp::JNIAdapter;

        extern "C" {

        `` apply "method", 0
        } // extern "C"

        ||

    template "method" {
        const "mangled" call "mangle";
        const "rettype", "name(parm[creates|returns]/*[2])";
        const "retname", "name(parm[creates|returns]/*[3])";
        const "jtype" call "toJavaDeclare" with "type", "$rettype";

        ||
        JNIEXPORT jobject JNICALL «$mangled»(
                JNIEnv *env,
                jobject obj`apply "parm[in]", mode=sig`
            )
        {
            PEP_SESSION session = (PEP_SESSION) callLongMethod(env, obj, "getHandle");

        ||

        apply "parm[in]", mode=in;
        apply "parm[creates|returns]", mode=out;
        ||

            PEP_STATUS status = ::«@name»(session`apply "parm", mode=call`);
            if ((status > PEP_STATUS_OK && status < PEP_UNENCRYPTED) |`> |`
                    status < PEP_STATUS_OK |`> |`
                    status >= PEP_TRUSTWORD_NOT_FOUND) {
                throw_pEp_Exception(env, status);
                return NULL;
            }

        ||

        choose {
            when "count(parm[returns|creates]) > 1" {
                apply "parm[returns|creates]", mode=return;

                apply "parm[1]", mode=return {
                    with "name" > result
                    with "jtype" > Engine$_«@name»_Return
                    with "sig" > (Lorg/pEp/jniadapter/Engine;)V
                    with "jnitype" > InnerClass
                }

                apply "parm[returns|creates]", mode=setresult
                    with "jtype" > org/pEp/jniadapter/Engine$_«@name»_Return

                ||
                    return result_;
                ||
            }

            when "count(parm[returns|creates]) = 1" {
                choose {
                    when "ancestor::namespace/child::enum[@name=$rettype]" apply "parm[returns|creates]", mode=return {
                        with "jtype", "$jtype";
                        with "jnitype", "'jint'";
                        with "sig", "'(I)V'";
                    }

                    when "$rettype = 'message' or $rettype = 'identity'" apply "parm[returns|creates]", mode=return {
                        with "jtype", "$jtype";
                        with "jnitype", "'jlong'";
                        with "sig", "'(J)V'";
                    }

                    when "$rettype = 'stringlist'" apply "parm[returns|creates]", mode=return;

                    otherwise error | # not implemented: return type "«$rettype»";
                }

                ||
                    return «name(parm[returns|creates]/*[3])»_;
                ||
            }
        }

        ||
        }

        ||
    }

    template "parm", mode=setresult {
        param "jtype";
        const "sig" call "toSig" with "type", "name(*[2])";
        const "name", "name(*[3])";
        ||
        jfieldID «$name»_field = getFieldID(env, "«$jtype»",
                    "«$name»", "«$sig»");
        if («$name»_)
            env->SetObjectField(result_, «$name»_field, «$name»_);
        ||
        if "$name = 'dst'"
        ||
        else
            env->SetObjectField(result_, «$name»_field, src);
        ||
        ||

        ||
    }

    template "parm", mode=return {
        param "type", "name(*[2])";
        param "jtype" call "toJava" with "type", "$type";
        param "name", "name(*[3])";
        param "jnitype" choose {
            when "$type = 'message'" > jlong
            when "ancestor::namespace/child::enum[@name=$type]" > jint
            when "$type = 'stringlist'" > jbyteArray
            otherwise >
        }
        param "retname", "$name";
        param "sig" choose {
            when "$type = 'message'" > (J)V
            when "ancestor::namespace/child::enum[@name=$type]" > (I)V
            when "$type = 'stringlist'" > (Ljava.lang.Object;)V
            otherwise > ()V
        }

        choose {
            when "$jnitype = 'jbyteArray'"
            ||
            jobject «$name»_ = NULL;
            if (_«$retname»)
                «$name»_ = from_stringlist(env, _«$retname»);

            ||

            when "$type = 'identity'"
            ||
            jobject «$name»_ = NULL;
            if (_«$retname»)
                «$name»_ = from_identity(env, _«$retname»);

            ||

            when "ancestor::namespace/child::enum[@name=$jtype]" {
            const "ljtype" call "lcase" with "text","$jtype";
            ||
            jobject «$name»_ = NULL;
            {
                jclass clazz_«$ljtype» = findClass(env, "org/pEp/jniadapter/«$jtype»");
                assert(clazz_«$ljtype»);
                jmethodID method_values = env->GetStaticMethodID(clazz_«$ljtype», "values",
                        "()[Lorg/pEp/jniadapter/«$jtype»;");
                assert(method_values);
                jfieldID field_value = env->GetFieldID(clazz_«$ljtype», "value", "I");
                assert(field_value);

                jobjectArray values = (jobjectArray) env->CallStaticObjectMethod(clazz_«$ljtype»,
                        method_values);
                assert(values);

                jsize values_size = env->GetArrayLength(values);
                for (jsize i = 0; i < values_size; i++) {
                    jobject element = env->GetObjectArrayElement(values, i);
                    assert(element);
                    jint value = env->GetIntField(element, field_value);
                    if (value == (jint) _«$name») {
                        «$name»_ = element;
                        break;
                    }
                }
            }

            ||
            }

            otherwise {
                | jobject «$name»_ = NULL;
                indent(0);
                if "$retname != 'result'" > if (_«$retname») 
                > {\n
                ||
                    jclass clazz_«$name»_ = findClass(env, "org/pEp/jniadapter/«$jtype»");
                    assert(clazz_«$name»_);
                    jmethodID constructor_«$name»_ = env->GetMethodID(clazz_«$name»_, "<init>", "«$sig»");
                    assert(constructor_«$name»_);
                ||

                indent(1);
                > «$name»_ = env->NewObject(clazz_«$name»_, constructor_«$name»_
                choose {
                    when "$jnitype = 'InnerClass'" > , obj
                    when "$jnitype != ''" > , («$jnitype») _«$retname»
                }
                > );\n

                ||
                }

                ||
            }
        }
    }

    template "parm", mode=in {
        const "type", "name(*[2])";
        const "name", "name(*[3])";

        choose {
            when "$type = 'message'"
                | message *_«$name» = (message *) callLongMethod(env, «$name», "getHandle");
            otherwise
                | √$type *_«$name» = to_«$type»(env, «$name»);
        }
    }

    template "parm", mode=out {
        param "name", "name(*[3])";
        const "type", "name(*[2])";

        choose {
            when "ancestor::namespace/child::enum[@name=$type]"
                | √$type _«$name»;
            otherwise
                | √$type *_«$name»;
        }
    }

    template "parm", mode=call {
        const "dir", "name(*[1])";
        const "name", "name(*[3])";
     
        > , 

        choose {
            when "$dir = 'Cconst'"
                value "*[3]";
            when "$dir = 'creates' or $dir = 'returns'" {
                > &_«$name»
            }
            otherwise {
                > _«$name»
            }
        }
    }

    function "mangle" {
        const "convert", "count(parm/stringlist|parm/string|parm/identity) > 0";

        choose {
            when "$convert"
                > «concat('Java_org_pEp_jniadapter_', ../@name, '__1', str:replace(@name, '_', '_1'))»
            otherwise
                > «concat('Java_org_pEp_jniadapter_', ../@name, '_', str:replace(@name, '_', '_1'))»
        }
    }

    template "parm", mode=sig {
        const "name", "name(*[3])";
        > ,\n        `call "jni_type" with "type", "name(*[2])"` «$name»
    }
}

