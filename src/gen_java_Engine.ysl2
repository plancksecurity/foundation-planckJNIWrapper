include yslt.yml2

tstylesheet {
    include ./textutils.ysl2
    include ./types_java.ysl2

    template "/namespace[@name='pEp']" apply "interface", 0;

    template "interface" {
        const "cname" call "toJava" with "type", "@name";
        document("org/pEp/jniadapter/{$cname}.java", "text")
            ||
            package org.pEp.jniadapter;

            import java.util.ArrayList;
            import java.util.Vector;

            final public class «$cname» extends AbstractEngine {
                public «$cname»() throws pEpException { }

                `` apply "method", mode=plain
                `` apply "basic"
            }

            ||
    }

    template "basic" {
        const "itype" call "toIntermediate" with "type", "@type";
        const "jtype" call "toJava" with "type", "@type";

        ||
        private native «$itype» «@name»(`apply "parm/*", mode=basic_iparm`);

        public «$jtype» «@name»(`apply "parm/*", mode=basic_parm`) {
        ||
        apply "parm/*", mode=basic_parm_set;
        choose {
            when "@type = 'void'"
                |> «@name»(`apply "parm/*", mode=basic_parm_name`);
            when "@type = 'identity'"
                |> return new Identity(«@name»(`apply "parm/*", mode=basic_parm_name`));
            when "@type = 'bool'"
                |> return new Boolean(«@name»(`apply "parm/*", mode=basic_parm_name`));
            otherwise
                |> return AbstractEngine.toUTF16(«@name»(`apply "parm/*", mode=basic_parm_name`));
        }
        ||
        }

        ||
    }
    
    template "*", mode=basic_parm_name choose {
        when "position() mod 2" {
            if "position() = 1 and name(.)='int'"
                > 23, 
            if "position() > 1" > , 
        }
        otherwise {
            > _«name(.)»
        }
    }

    template "*", mode=basic_parm choose {
        when "position() mod 2" {
            if "position() > 1" > , 
            choose {
                when "name(.) = 'string'"
                    > String 
                when "name(.) = 'identity'"
                    > Identity 
                when "name(.) = 'bool'"
                    > Boolean 
                otherwise
                    > «name(.)» 
            }
        }
        otherwise {
            > «name(.)»
        }
    }

    template "*", mode=basic_iparm choose {
        when "position() mod 2" {
            const "pitype" call "toIntermediate" with "type", "name(.)";
            if "position() = 1 and name(.)='int'"
                > int dummy, 
            if "position() > 1" > , 
            > «$pitype» 
        }
        otherwise {
            > «name(.)»
        }
    }

    template "*", mode=basic_parm_set {
        const "ptype", "name(preceding-sibling::*[1])";
        const "pname", "name(.)";
        const "pitype" call "toIntermediate" with "type", "$ptype";

        if "not(position() mod 2)" choose {
            when "$ptype = 'string'"
            | «$pitype» _«$pname» = «$pname».getBytes();
            when "$ptype = 'bool'"
            | «$pitype» _«$pname» = «$pname».booleanValue();
            when "$ptype = 'int'"
            | «$pitype» _«$pname» = «$pname»; 
            when "ancestor::namespace/child::enum[@name=$ptype]"
            | «$pitype» _«$pname» = «$pname».value;
            otherwise
            | «$pitype» _«$pname» = new «$pitype»(«$pname»);
        }
    }

    function "returnJava" {
        const "returning", "count(parm/creates|parm/returns)";
        const "returntype" call "toJava" with "type", "name(parm[creates|returns]/*[2])";

        choose {
            when "$returning = 0" > void
            when "$returning = 1" > «$returntype»
            otherwise > «@name»_Return
        }
    }

    function "returnInter" {
        const "returning", "count(parm/creates|parm/returns)";
        const "returntype" call "toIntermediate" with "type", "name(parm[creates|returns]/*[2])";

        choose {
            when "$returning = 0" > void
            when "$returning = 1" > «$returntype»
            otherwise > _«@name»_Return
        }
    }

    template "method", mode=plain {
        const "convert", "count(parm/stringlist|parm/stringpairlist|parm/string|parm/identity|parm/identitylist) > 0";
        const "singlereturn", "count(parm/creates|parm/returns|parm/inout[../int]) = 1";
        const "multireturn", "count(parm/creates|parm/returns|parm/inout[../int]) > 1";

        if "$multireturn" {
            if "$convert"
            ||
            private class _«@name»_Return {
            `` apply "parm[creates|returns|inout[../int]]", 1, mode=intermediate with "public", 1;
            }

            ||

            ||
            public class «@name»_Return {
            `` apply "parm[creates|returns|inout[../int]]", 1, mode=java with "public", 1;
            }

            ||
        }

        if "$convert"
        ||
        private native `call "returnInter"` _«@name»(
        `` apply "parm[in|inout]", 2, mode=intermediate
            ) throws pEpException;

        ||

        ||
        public `if "not($convert)" > native ``call "returnJava"` «@name»(
        `` apply "parm[in|inout]", 2, mode=java
            ) throws pEpException`if "not($convert)" > ;`
        ||

        if "$convert" {
            | {
            apply "parm", mode=convertIn;

            if "$singlereturn" choose {

                // TODO factorize type conversion with multireturn and gen_java_message.java

                when "count(parm[returns][stringlist|string|sstring]) > 0"
                    |> return AbstractEngine.toUTF16(_«@name»(`apply "parm[in]", mode=call;`));
                when "count(parm[returns]/stringpairlist) > 0"
                    ||
                        ArrayList<Pair<byte[], byte[]>> glist = _«@name»(`apply "parm[in]", mode=call;`);
                        if(glist != null){
                            ArrayList<Pair<String, String>> list = new ArrayList<Pair<String, String>>();
                            for (Pair<byte[],byte[]> i : glist)
                                list.add(new Pair<String, String>(AbstractEngine.toUTF16(i.first), AbstractEngine.toUTF16(i.second)));
                            return list;
                        }
                        return null;
                    ||

                when "count(parm[returns]/identity) > 0"
                    |> return new Identity(_«@name»(`apply "parm[in]", mode=call;`));
                when "count(parm[returns]/identitylist) > 0"
                    ||
                        Vector<_Identity> glist = _«@name»(`apply "parm[in]", mode=call;`);
                        if(glist != null){
                            Vector<Identity> list = new Vector<Identity>();
                            for (_Identity i : glist)
                                list.add(new Identity(i));
                            return list;
                        }
                        return null;
                    ||
                otherwise
                    |> return _«@name»(`apply "parm[in]", mode=call;`);
            }

            if "$multireturn"
            ||
                _«@name»_Return _result = _«@name»(`apply "parm[in|inout]", mode=call;`);
                «@name»_Return result = new «@name»_Return();
                `` apply "parm[creates|returns|inout[../int]]", mode=convertOut;
                return result;
            ||

            if "not($singlereturn) and not($multireturn)"
            ||
                _«@name»(`apply "parm[in]", mode=call;`);
                return;
            ||
                
            ||
            }
            ||
        }
        ||

        ||
    }

    template "parm", mode=java {
        param "public", 0;
        const "dir", "name(*[1])";
        const "type", "name(*[2])";
        const "name", "name(*[3])";

        indent(0);

        if "$public" > public 
        call "toJava" with "type", "$type";
        >  «translate($name,'-','_')»
        choose {
            when "$public" > ;
            otherwise if "position()!=last()" > ,
        }
        > \n
    }

    template "parm", mode=intermediate {
        param "public", 0;
        const "dir", "name(*[1])";
        const "type", "name(*[2])";
        const "name", "name(*[3])";

        indent(0);

        if "$public" > public 
        call "toIntermediate" with "type", "$type", with "dir", "$dir";
        >  «translate($name,'-','_')»
        choose {
            when "$public" > ;
            otherwise if "position()!=last()" > ,
        }
        > \n
    }

    template "parm", mode=convertIn {
        const "dir", "name(*[1])";
        const "type", "name(*[2])";
        const "name" call "lcase" with "text", "name(*[3])";

        if "$dir = 'in' or $dir = 'inout'" choose {
            when "$type = 'string' or $type = 'stringlist'"
                | ¡$type _«$name» = AbstractEngine.toUTF8(«$name»);
            when "$type = 'identity'"
                | _Identity _«$name» = new _Identity(«$name»);
        }
    }

    template "parm", mode=convertOut {
        const "dir", "name(*[1])";
        const "type", "name(*[2])";
        const "name" call "lcase" with "text", "name(*[3])";

        if "$dir != 'in'" choose {
            when "$type = 'string' or $type = 'stringlist'"
                | result.«$name» = AbstractEngine.toUTF16(_result.«$name»);
            when "$type = 'identity'"
                | result.«$name» = Identity(«$name»);
            otherwise
                | result.«$name» = _result.«$name»;
        }
    }

    template "parm", mode=call {
        const "type", "name(*[2])";
        const "name" call "lcase" with "text", "name(*[3])";

        if "$type = 'string' or $type = 'stringlist' or $type = 'identity'"
            > _
        > «$name»`if "position()!=last()" > , `
    }
}

