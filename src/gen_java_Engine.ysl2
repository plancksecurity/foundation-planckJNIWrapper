include yslt.yml2

tstylesheet {
    include ./textutils.ysl2
    include ./types_java.ysl2

    template "/namespace[@name='pEp']" apply "interface", 0;

    template "interface" {
        const "cname" call "toJava" with "type", "@name";
        document("org/pEp/jniadapter/{$cname}.java", "text")
            ||
            package org.pEp.jniadapter;

            import java.util.Vector;

            final public class «$cname» extends AbstractEngine {
                public «$cname»() throws pEpException { }

                `` apply "method", mode=plain
                `` apply "basic"
            }

            ||
    }

    template "basic" {
        const "itype" call "toIntermediate" with "type", "@type";
        const "jtype" call "toJava" with "type", "@type";
        const "ptype", "name(parm/*[1])";
        const "pitype" call "toIntermediate" with "type", "$ptype";
        const "pjtype" call "toJava" with "type", "$ptype";
        const "pname", "name(parm/*[2])";

        ||
        private native «$itype» «@name»(«$pitype» «$pname»);

        public «$jtype» «@name»(«$pjtype» «$pname») {
        ||
        choose {
            when "$ptype = 'string'"
            |> «$pitype» _«$pname» = «$pname».getBytes();
            when "$ptype = 'bool'"
            |> «$pitype» _«$pname» = «$pname».booleanValue();
            when "ancestor::namespace/child::enum[@name=$ptype]"
            |> «$pitype» _«$pname» = «$pname».value();
            otherwise
            |> «$pitype» _«$pname» = new «$pitype»(«$pname»);
        }
        choose {
            when "@type = 'void'"
                |> «@name»(_«$pname»);
            when "@type = 'identity'"
                |> return new Identity(«@name»(_«$pname»));
            when "@type = 'bool'"
                |> return new Boolean(«@name»(_«$pname»));
            otherwise
                |> return AbstractEngine.toUTF16(«@name»(_«$pname»));
        }
        ||
        }

        ||
    }

    function "returnJava" {
        const "returning", "count(parm/creates|parm/returns)";
        const "returntype" call "toJava" with "type", "name(parm[creates|returns]/*[2])";

        choose {
            when "$returning = 0" > void
            when "$returning = 1" > «$returntype»
            otherwise > «@name»_Return
        }
    }

    function "returnInter" {
        const "returning", "count(parm/creates|parm/returns)";
        const "returntype" call "toIntermediate" with "type", "name(parm[creates|returns]/*[2])";

        choose {
            when "$returning = 0" > void
            when "$returning = 1" > «$returntype»
            otherwise > _«@name»_Return
        }
    }

    template "method", mode=plain {
        const "convert", "count(parm/stringlist|parm/string|parm/identity) > 0";
        const "singlereturn", "count(parm/creates|parm/returns) = 1";
        const "multireturn", "count(parm/creates|parm/returns) > 1";

        if "$multireturn" {
            if "$convert"
            ||
            private class _«@name»_Return {
            `` apply "parm[creates|returns]", 1, mode=intermediate with "public", 1;
            }

            ||

            ||
            public class «@name»_Return {
            `` apply "parm[creates|returns]", 1, mode=java with "public", 1;
            }

            ||
        }

        if "$convert"
        ||
        private native `call "returnInter"` _«@name»(
        `` apply "parm[in]", 2, mode=intermediate
            ) throws pEpException;

        ||

        ||
        public `if "not($convert)" > native ``call "returnJava"` «@name»(
        `` apply "parm[in]", 2, mode=java
            ) throws pEpException`if "not($convert)" > ;`
        ||

        if "$convert" {
            | {
            apply "parm", mode=convertIn;

            if "$singlereturn" choose {
                when "count(parm[returns]/stringlist|parm[returns]/string) > 0"
                    |> return AbstractEngine.toUTF16(_«@name»(`apply "parm[in]", mode=call;`));
                when "count(parm[returns]/identity) > 0"
                    |> return new Identity(_«@name»(`apply "parm[in]", mode=call;`));
                otherwise
                    |> return _«@name»(`apply "parm[in]", mode=call;`);
            }

            if "$multireturn"
            ||
                _«@name»_Return _result = _«@name»(`apply "parm[in]", mode=call;`);
                «@name»_Return result = new «@name»_Return();
                `` apply "parm[creates|returns]", mode=convertOut;
                return result;
            ||

            ||
            }
            ||
        }
        ||

        ||
    }

    template "parm", mode=java {
        param "public", 0;
        const "dir", "name(*[1])";
        const "type", "name(*[2])";
        const "name", "name(*[3])";

        indent(0);

        if "$public" > public 
        > †$type «translate($name,'-','_')»
        choose {
            when "$public" > ;
            otherwise if "position()!=last()" > ,
        }
        > \n
    }

    template "parm", mode=intermediate {
        param "public", 0;
        const "dir", "name(*[1])";
        const "type", "name(*[2])";
        const "name", "name(*[3])";

        indent(0);

        if "$public" > public 
        > ¡$type «translate($name,'-','_')»
        choose {
            when "$public" > ;
            otherwise if "position()!=last()" > ,
        }
        > \n
    }

    template "parm", mode=convertIn {
        const "dir", "name(*[1])";
        const "type", "name(*[2])";
        const "name" call "lcase" with "text", "name(*[3])";

        if "$dir = 'in'" choose {
            when "$type = 'string' or $type = 'stringlist'"
                | ¡$type _«$name» = AbstractEngine.toUTF8(«$name»);
            when "$type = 'identity'"
                | _Identity _«$name» = new _Identity(«$name»);
        }
    }

    template "parm", mode=convertOut {
        const "dir", "name(*[1])";
        const "type", "name(*[2])";
        const "name" call "lcase" with "text", "name(*[3])";

        if "$dir != 'in'" choose {
            when "$type = 'string' or $type = 'stringlist'"
                | result.«$name» = AbstractEngine.toUTF16(_result.«$name»);
            when "$type = 'identity'"
                | result.«$name» = Identity(«$name»);
            otherwise
                | result.«$name» = _result.«$name»;
        }
    }

    template "parm", mode=call {
        const "type", "name(*[2])";
        const "name" call "lcase" with "text", "name(*[3])";

        if "$type = 'string' or $type = 'stringlist' or $type = 'identity'"
            > _
        > «$name»`if "position()!=last()" > , `
    }
}

