include yslt.yml2

tstylesheet {
    include ./textutils.ysl2
    include ./types_java.ysl2

    template "/namespace[@name='pEp']" apply "struct|enum|exception", 0;

    template "struct" {
        const "cname" call "toJava" with "type", "@name";
        document("foundation/pEp/jniadapter/{$cname}.java", "text")
            ||
            package foundation.pEp.jniadapter;

            import java.util.ArrayList;
            import java.util.Vector;
            import java.util.Date;
            import java.util.HashMap;
            import java.io.Serializable;

            public class «$cname» implements AutoCloseable, Serializable {
                private static final long serialVersionUID = 2119420428331150924L;
                private long handle;

                native long init();
                native void release(long handle);

                public «$cname»() {
                    handle = init();
                }

                private native long _«$cname»(
                        byte[] mime_text
                    ) throws pEpException;
                
                public «$cname»(String mime_text) {
                    byte[] _mime_text = AbstractEngine.toUTF8(mime_text);
                    handle = _«$cname»(_mime_text);
                }

                public native byte[] _encodeMIME() throws pEpException;

                public String encodeMIME() {
                    return AbstractEngine.toUTF16(_encodeMIME());
                }

                private «$cname»(long h) {
                    handle = h;
                }

                public final void close() {
                    release(handle);
                }

                final protected long getHandle() {
                    return handle;
                }

                `` apply "enum", mode=inner
                `` apply "*[name(.)!='enum']", mode=entry
            }
            ||
    }

    template "enum|exception" {
        const "jname" call "toJava" with "type", "@name";
        document("foundation/pEp/jniadapter/{$jname}.java", "text")
            ||
            package foundation.pEp.jniadapter;

            import java.util.HashMap;
            
            `` apply ".", 0, mode=inner
            ||
    }

    template "enum|exception", mode=inner {
        const "jname" call "CamelCase" with "text", "@name";
        ||
        public enum «$jname» {
            `` apply "*", mode=value
            ;

            public final int value;

            private static HashMap<Integer, «$jname»> intMap;

            private «$jname»(int value) {
                this.value = value;
            }

            public static «$jname» getByInt(int value){
                if (intMap == null) {
                    intMap = new HashMap<Integer, «$jname»>();
                    for («$jname» s : «$jname».values()) {
                        intMap.put(s.value, s);
                    }
                }
                if (intMap.containsKey(value)) {
                    return intMap.get(value);
                }
                return null;
            }
        }
        ||
    }

    template "*", mode=entry {
        const "ctype", "name(.)";
        const "type" call "toJava" with "type", "name(.)";
        const "itype" call "toIntermediate" with "type", "name(.)";
        const "name" call "toJava" with "type", "name(*[position()=1])";

        choose {
            when "$ctype = 'identity'"
            ||
            private native «$itype» _get«$name»();
            private native void _set«$name»(«$itype» value);
            public «$type» get«$name»() {
                «$itype» res = _get«$name»();
                if(res != null){
                    return new «$type»(_get«$name»());
                }else{
                    return null;
                }
            }
            public void set«$name»(«$type» value) {
                if(value != null)
                    _set«$name»(new «$itype»(value));
                else
                    _set«$name»(null);
            }
            
            ||

            when "$ctype = 'identitylist' or $ctype = 'bloblist' or $ctype = 'stringlist' or $ctype = 'stringpairlist'"
            {

                const "ename", "substring-after(substring($type,1,string-length($type)-1), '<')";
                const "iename" choose {
                    when "$ctype = 'stringlist'" > byte[]
                    when "$ctype = 'stringpairlist'" > Pair<byte[],byte[]>
                    otherwise > _«$ename»
                }
                const "convget" choose {
                    when "$ctype = 'stringlist'" > AbstractEngine.toUTF16(i)
                    when "$ctype = 'stringpairlist'" > new Pair<String, String>(AbstractEngine.toUTF16(i.first), AbstractEngine.toUTF16(i.second))
                    otherwise > new «$ename»(i)
                }
                const "convset" choose {
                    when "$ctype = 'stringlist'" > AbstractEngine.toUTF8(i)
                    when "$ctype = 'stringpairlist'" > new Pair<byte[],byte[]>(AbstractEngine.toUTF8(i.first), AbstractEngine.toUTF8(i.second))
                    otherwise > new _«$ename»(i)
                }
                ||
                private native «$itype» _get«$name»();
                private native void _set«$name»(«$itype» value);
                public «$type» get«$name»() {
                    «$itype» glist = _get«$name»();
                    if(glist != null){
                        «$type» list = new «$type»();
                        for («$iename» i : glist)
                            list.add(«$convget»);
                        return list;
                    }
                    return null;
                }
                public void set«$name»(«$type» value) {
                    if(value != null){
                        «$itype» list = new «$itype»();
                        for («$ename» i : value)
                            list.add(«$convset»);
                        _set«$name»(list);
                    }else{
                        _set«$name»(null);
                    }
                }
                
                ||
            }
            
            when "$itype != $type"
            ||
            private native «$itype» _get«$name»();
            private native void _set«$name»(«$itype» value);
            public «$type» get«$name»() {
                «$itype» res = _get«$name»();
                if(res != null)
                    return AbstractEngine.toUTF16(res);
                else
                    return null;
            }
            public void set«$name»(«$type» value) {
                if(value != null)
                    _set«$name»(AbstractEngine.toUTF8(value));
                else
                    _set«$name»(new byte[0]);
            }

            ||

            when "$itype != $type"
            ||
            private native «$itype» _get«$name»();
            private native void _set«$name»(«$itype» value);
            public «$type» get«$name»() {
                «$itype» res = _get«$name»();
                if(res != null)
                    return AbstractEngine.toUTF16(res);
                else
                    return null;
            }
            public void set«$name»(«$type» value) {
                if(value != null)
                    _set«$name»(AbstractEngine.toUTF8(value));
                else
                    _set«$name»(null);
            }

            ||

            when "../enum[@name=$ctype]"
            ||
            private native int _get«$name»();
            public «$itype» get«$name»() {
                return «$itype».getByInt(_get«$name»());
            }
            private native void _set«$name»(int value);
            public void set«$name»(«$itype» value) {
                if(value != null)
                    _set«$name»(value.value);
                else
                    _set«$name»(0);
            }

            ||

            otherwise
            ||
            public native «$itype» get«$name»();
            public native void set«$name»(«$itype» value);

            ||
        }
    }

    template "*", mode=value {
        const "name" call "toJava" with "type", "name(.)";
        | «$name» («.»)`if "position()!=last()" > , `
    }
}

